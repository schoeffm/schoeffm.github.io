<?xml version="1.0" encoding="utf-8" standalone="yes"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>Posts on Personal PasteBin</title>
    <link>https://schoeffm.github.io/posts/</link>
    <description>Recent content in Posts on Personal PasteBin</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>en-us</language>
    <lastBuildDate>Wed, 29 Jan 2020 15:07:59 +0100</lastBuildDate>
    
	<atom:link href="https://schoeffm.github.io/posts/index.xml" rel="self" type="application/rss+xml" />
    
    
    <item>
      <title>jq by example</title>
      <link>https://schoeffm.github.io/posts/jq-by-example/</link>
      <pubDate>Wed, 29 Jan 2020 15:07:59 +0100</pubDate>
      
      <guid>https://schoeffm.github.io/posts/jq-by-example/</guid>
      <description>Inspired by a nice tutorial on Baeldung I&amp;rsquo;ve decided to write done some usual suspects when working with jq. Hence, this is more like a cheatsheet than a regular post.
For practitioners and interactive learners I also recommend the great jq-play online editor where you can try jq directly in the browser.
For our examples below let&amp;rsquo;s go with the followin&amp;rsquo; JSON-input (fetched from a micro-profile /health-endpoint).
{ &amp;#34;outcome&amp;#34;: &amp;#34;UP&amp;#34;, &amp;#34;checks&amp;#34;: [ { &amp;#34;name&amp;#34;: &amp;#34;core-isAlive&amp;#34;, &amp;#34;state&amp;#34;: &amp;#34;UP&amp;#34;, &amp;#34;data&amp;#34;: { &amp;#34;buildtime&amp;#34;: &amp;#34;2020-01-29T12:46:05.</description>
    </item>
    
    <item>
      <title>Access Host From Inside a Docker Container</title>
      <link>https://schoeffm.github.io/posts/access-host-from-inside-a-docker-container/</link>
      <pubDate>Wed, 01 Jan 2020 12:00:56 +0100</pubDate>
      
      <guid>https://schoeffm.github.io/posts/access-host-from-inside-a-docker-container/</guid>
      <description>This is more a bookmark than a post - but I&amp;rsquo;d like to write it down explicitly since everytime I need this I have to google it (and cutting through the false positivies sucks).
 From 18.03 onwards our recommendation is to connect to the special DNS name host.docker.internal, which resolves to the internal IP address used by the host.
 This was taken from the docker-for-mac documentation were you can find more details.</description>
    </item>
    
    <item>
      <title>Ntlm Authentication in Java</title>
      <link>https://schoeffm.github.io/posts/ntlm-authentication-in-java/</link>
      <pubDate>Fri, 20 Sep 2019 07:52:55 +0200</pubDate>
      
      <guid>https://schoeffm.github.io/posts/ntlm-authentication-in-java/</guid>
      <description>&lt;p&gt;Recently I had to integrate a java based application with a web-service that used NTLM authentication. Since this was the first time I came across NTLM I initially had to explore how to deal with that auth-scheme. &lt;!-- raw HTML omitted --&gt;
Luckily, I finally stumbled upon the &lt;code&gt;Authenticator&lt;/code&gt;-class in Java and learned that there is build in support for NTLM already.&lt;!-- raw HTML omitted --&gt;&lt;/p&gt;</description>
    </item>
    
    <item>
      <title>Network Debugging of Containerized Java Apps</title>
      <link>https://schoeffm.github.io/posts/network-debugging-of-containerized-java-apps/</link>
      <pubDate>Thu, 19 Sep 2019 16:27:21 +0200</pubDate>
      
      <guid>https://schoeffm.github.io/posts/network-debugging-of-containerized-java-apps/</guid>
      <description>&lt;p&gt;The other day, I had the need to look closer into the network communication of a (dockerized) JEE application. My usual &lt;a href=&#34;https://schoeffm.github.io/posts/tcpdump-common-commands/&#34;&gt;tcpdump approach&lt;/a&gt; wasn&amp;rsquo;t applicable though because the traffic was TLS-encrypted.&lt;!-- raw HTML omitted --&gt;
Finally, I ended up with a setup where the app used a &lt;a href=&#34;https://mitmproxy.org&#34;&gt;man-in-the-middle proxy&lt;/a&gt; for all its communication - that proxy transparently re-encrypted the traffic which gave me the chance to inspect every single message exchanged.&lt;/p&gt;</description>
    </item>
    
    <item>
      <title>Cors by Example</title>
      <link>https://schoeffm.github.io/posts/cors-by-example/</link>
      <pubDate>Fri, 30 Aug 2019 15:33:13 +0200</pubDate>
      
      <guid>https://schoeffm.github.io/posts/cors-by-example/</guid>
      <description>More often than not CORS mean little more to developers than just getting rid of the infamous browser error in order to continue cranking out features as soon as possible. In other words, it&amp;rsquo;s not the best understood concept out there.
Hence, to shed more light upon the topic, I&amp;rsquo;d like to give some working examples of CORS setups and show why they work. The more detailed explanation about the backing concepts I relinquish to the excellent MDN documentation if you&amp;rsquo;d like to dig deeper.</description>
    </item>
    
    <item>
      <title>Using load-tests as quality gate in Jenkins pipelines</title>
      <link>https://schoeffm.github.io/posts/integration-of-loadtests-within-jenkins-pipelines/</link>
      <pubDate>Wed, 14 Aug 2019 10:41:28 +0200</pubDate>
      
      <guid>https://schoeffm.github.io/posts/integration-of-loadtests-within-jenkins-pipelines/</guid>
      <description>&lt;p&gt;Over years &lt;a href=&#34;https://jmeter.apache.org/&#34;&gt;JMeter&lt;/a&gt; has always been a valuable tool in my box when dealing with performance testing. But when we&amp;rsquo;ve integrated those tests with our CI/CD-pipeline we always had hard times to control the pipeline outcome based on the performance results. &lt;!-- raw HTML omitted --&gt;
In other words, let the test results act as a quality gate for either promoting the build-artfiact along the pipeline or not.&lt;/p&gt;</description>
    </item>
    
    <item>
      <title>Linux User Management</title>
      <link>https://schoeffm.github.io/posts/linux-user-management/</link>
      <pubDate>Sat, 10 Aug 2019 10:40:33 +0200</pubDate>
      
      <guid>https://schoeffm.github.io/posts/linux-user-management/</guid>
      <description>Cheatsheet for Linux User Management
Handling users # adds a new user called &amp;#39;schoeffm&amp;#39; useradd -m -s /bin/zsh -G docker schoeffm # └┬┘└────┬─────┘└─┬─────┘ # │ │ │ # │ │ └─&amp;gt; List of groups the user # │ │ should be a member of # │ └─&amp;gt; login shell of the new account # └────────&amp;gt; also create a home directory for this # account # Assigns a new UID to &amp;lt;─────┐ # this account │ # ┌──┴──┐ usermod -aG docker -s /bin/zsh -L|U -u 4711 schoeffm # └───┬────┘ └───┬─────┘ └─┬─┘ # │ │ └─&amp;gt; Lock or Unlock user # │ └─&amp;gt; set new login shell for account # └────────────&amp;gt; append to the list of groups # without &amp;#39;a&amp;#39; this will replace # the group list userdel not explicitly shown here since it&amp;rsquo;s comprehensible.</description>
    </item>
    
    <item>
      <title>Linux Permission Management</title>
      <link>https://schoeffm.github.io/posts/linux-permission-management/</link>
      <pubDate>Tue, 06 Aug 2019 08:59:37 +0200</pubDate>
      
      <guid>https://schoeffm.github.io/posts/linux-permission-management/</guid>
      <description>Cheatsheet for Linux Permission Management
Standard Permissions There are three basic permissions which are read, write and execute. And they can be granted to
 a specific user (so if you are not that user those permissions do not apply to you) a group of users (if you&amp;rsquo;re not a member of that group those permissions do not apply to you) to all other users (so if the first two do not apply - these are then the permissions you&amp;rsquo;ll have on the respective file/directory)  This is also the order in which linux checks the permissions.</description>
    </item>
    
    <item>
      <title>Testing Web Components</title>
      <link>https://schoeffm.github.io/posts/testing-web-components/</link>
      <pubDate>Fri, 02 Aug 2019 08:14:21 +0200</pubDate>
      
      <guid>https://schoeffm.github.io/posts/testing-web-components/</guid>
      <description>&lt;p&gt;Testing web-components in isolation can be a challenging task. The (&lt;em&gt;current&lt;/em&gt;) usual suspects in this area still &lt;a href=&#34;https://github.com/jsdom/jsdom/issues/1030&#34;&gt;lack support for the standard&lt;/a&gt; and thus cannot be used (at least at the time of this writing). Also, the web is swamped by posts about frameworks and thus finding good example projects or tutorials is also challenging.&lt;!-- raw HTML omitted --&gt;
Finally, we found, at least for our project, a good solution which does the job and whose setup I&amp;rsquo;d like to write down/preserve (find the &lt;a href=&#34;https://github.com/schoeffm/testing-web-components&#34;&gt;corrsponding code in this repo&lt;/a&gt;).&lt;/p&gt;</description>
    </item>
    
    <item>
      <title>Tcpdump Common Commands</title>
      <link>https://schoeffm.github.io/posts/tcpdump-common-commands/</link>
      <pubDate>Tue, 30 Jul 2019 10:08:07 +0200</pubDate>
      
      <guid>https://schoeffm.github.io/posts/tcpdump-common-commands/</guid>
      <description>&lt;p&gt;When debugging network related issues the CLI tool &lt;code&gt;tcpdump&lt;/code&gt; is a valuable assistant. I usually use a variation of this base command:&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-bash&#34; data-lang=&#34;bash&#34;&gt;    sudo tcpdump -A -i lo0 -n -s0 -v port &lt;span style=&#34;color:#ae81ff&#34;&gt;8080&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;</description>
    </item>
    
    <item>
      <title>Response streaming between JAX-RS and Web-Components (Part 2)</title>
      <link>https://schoeffm.github.io/posts/response-streaming-between-jaxrs-and-webcomponents-part2/</link>
      <pubDate>Sun, 28 Jul 2019 12:18:59 +0200</pubDate>
      
      <guid>https://schoeffm.github.io/posts/response-streaming-between-jaxrs-and-webcomponents-part2/</guid>
      <description>&lt;p&gt;In &lt;a href=&#34;https://schoeffm.github.io/posts/response-streaming-between-jaxrs-and-webcomponents-part1/&#34;&gt;part one&lt;/a&gt; we had a look at a JAX-RS endpoint that streams its content to the requesting client. Now I&amp;rsquo;d like to show how the &lt;code&gt;fetch&lt;/code&gt;-API can be used to consume that streamed content in a web component.&lt;/p&gt;</description>
    </item>
    
    <item>
      <title>Response streaming between JAX-RS and Web-Components (Part 1)</title>
      <link>https://schoeffm.github.io/posts/response-streaming-between-jaxrs-and-webcomponents-part1/</link>
      <pubDate>Sat, 27 Jul 2019 11:18:59 +0200</pubDate>
      
      <guid>https://schoeffm.github.io/posts/response-streaming-between-jaxrs-and-webcomponents-part1/</guid>
      <description>&lt;p&gt;When dealing with JAX-RS resources are normally assembled completely in memory before being put onto the wire for transmission. If the resulting response fits into one single chunk the transmission is accomplished in one go - if the content is bigger than 16kB it will be split into several chunks of that size. You can see the difference in the response headers where a one-go-transmission contains the &lt;code&gt;Content-Length&lt;/code&gt;-header (where the server announces the size of the content to be transmitted) while a chunked transmission lacks the &lt;code&gt;Content-Length&lt;/code&gt; header but contains a &lt;code&gt;Transfer-Encoding: chunked&lt;/code&gt; header.&lt;/p&gt;</description>
    </item>
    
    <item>
      <title>Easy en-/decoding using base64</title>
      <link>https://schoeffm.github.io/posts/easy-en-decoding-using-base64/</link>
      <pubDate>Sat, 13 Jul 2019 14:58:39 +0200</pubDate>
      
      <guid>https://schoeffm.github.io/posts/easy-en-decoding-using-base64/</guid>
      <description>&lt;p&gt;When dealing with &lt;a href=&#34;https://kubernetes.io/docs/concepts/configuration/secret/&#34;&gt;Kubernetes secrets&lt;/a&gt; or when testing REST-services using i.e. &lt;code&gt;curl&lt;/code&gt; it&amp;rsquo;s nice to have a fast&amp;rsquo;n&amp;rsquo;easy way of de- and encoding characters using &lt;a href=&#34;https://de.wikipedia.org/wiki/Base64&#34;&gt;base64&lt;/a&gt;.&lt;/p&gt;</description>
    </item>
    
    <item>
      <title>SSH Config Format</title>
      <link>https://schoeffm.github.io/posts/ssh-config-format/</link>
      <pubDate>Mon, 24 Jun 2019 15:35:15 +0200</pubDate>
      
      <guid>https://schoeffm.github.io/posts/ssh-config-format/</guid>
      <description>&lt;p&gt;Dealing with SSH-connections can become cumbersome quickly especially when configurations change frequently, too.&lt;/p&gt;
&lt;p&gt;Luckily, you can pre-configure most of a connections settings in a user specific config-file located in your &lt;code&gt;~/.ssh&lt;/code&gt;-folder called &lt;code&gt;config&lt;/code&gt;.&lt;/p&gt;</description>
    </item>
    
    <item>
      <title>API versioning using vender specific media types in JAX-RS</title>
      <link>https://schoeffm.github.io/posts/api-versioning-with-vendor-specific-media-types/</link>
      <pubDate>Mon, 10 Jun 2019 10:40:12 +0200</pubDate>
      
      <guid>https://schoeffm.github.io/posts/api-versioning-with-vendor-specific-media-types/</guid>
      <description>&lt;p&gt;Content Negotiation in JAX-RS allows you to leverage the information in the client requests &lt;code&gt;Accept&lt;/code&gt; header to map that request to a specific handler-method within your application. In combination with vendor-specific media types this approach can be used for &lt;a href=&#34;http://blog.steveklabnik.com/posts/2011-07-03-nobody-understands-rest-or-http&#34;&gt;versioning of an API&lt;/a&gt;.&lt;/p&gt;</description>
    </item>
    
  </channel>
</rss>