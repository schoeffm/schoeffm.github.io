<?xml version="1.0" encoding="utf-8" standalone="yes"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>streaming on Personal PasteBin</title>
    <link>https://schoeffm.github.io/tags/streaming/</link>
    <description>Recent content in streaming on Personal PasteBin</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>en-us</language>
    <lastBuildDate>Sun, 28 Jul 2019 12:18:59 +0200</lastBuildDate>
    
	<atom:link href="https://schoeffm.github.io/tags/streaming/index.xml" rel="self" type="application/rss+xml" />
    
    
    <item>
      <title>Response streaming between JAX-RS and Web-Components (Part 2)</title>
      <link>https://schoeffm.github.io/posts/response-streaming-between-jaxrs-and-webcomponents-part2/</link>
      <pubDate>Sun, 28 Jul 2019 12:18:59 +0200</pubDate>
      
      <guid>https://schoeffm.github.io/posts/response-streaming-between-jaxrs-and-webcomponents-part2/</guid>
      <description>&lt;p&gt;In &lt;a href=&#34;https://schoeffm.github.io/posts/response-streaming-between-jaxrs-and-webcomponents-part1/&#34;&gt;part one&lt;/a&gt; we had a look at a JAX-RS endpoint that streams its content to the requesting client. Now I&amp;rsquo;d like to show how the &lt;code&gt;fetch&lt;/code&gt;-API can be used to consume that streamed content in a web component.&lt;/p&gt;</description>
    </item>
    
    <item>
      <title>Response streaming between JAX-RS and Web-Components (Part 1)</title>
      <link>https://schoeffm.github.io/posts/response-streaming-between-jaxrs-and-webcomponents-part1/</link>
      <pubDate>Sat, 27 Jul 2019 11:18:59 +0200</pubDate>
      
      <guid>https://schoeffm.github.io/posts/response-streaming-between-jaxrs-and-webcomponents-part1/</guid>
      <description>&lt;p&gt;When dealing with JAX-RS resources are normally assembled completely in memory before being put onto the wire for transmission. If the resulting response fits into one single chunk the transmission is accomplished in one go - if the content is bigger than 16kB it will be split into several chunks of that size. You can see the difference in the response headers where a one-go-transmission contains the &lt;code&gt;Content-Length&lt;/code&gt;-header (where the server announces the size of the content to be transmitted) while a chunked transmission lacks the &lt;code&gt;Content-Length&lt;/code&gt; header but contains a &lt;code&gt;Transfer-Encoding: chunked&lt;/code&gt; header.&lt;/p&gt;</description>
    </item>
    
  </channel>
</rss>