<?xml version="1.0" encoding="utf-8" standalone="yes"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>microprofile on Personal PasteBin</title>
    <link>https://schoeffm.github.io/tags/microprofile/</link>
    <description>Recent content in microprofile on Personal PasteBin</description>
    <generator>Hugo -- gohugo.io</generator>
    <lastBuildDate>Sun, 29 Mar 2020 18:35:36 +0200</lastBuildDate><atom:link href="https://schoeffm.github.io/tags/microprofile/index.xml" rel="self" type="application/rss+xml" />
    <item>
      <title>Towards Flexible Metrics Using SimplyTimed</title>
      <link>https://schoeffm.github.io/posts/towards-flexible-metrics-using-simplytimed/</link>
      <pubDate>Sun, 29 Mar 2020 18:35:36 +0200</pubDate>
      
      <guid>https://schoeffm.github.io/posts/towards-flexible-metrics-using-simplytimed/</guid>
      <description>&lt;p&gt;When &lt;a href=&#34;https://github.com/eclipse/microprofile-metrics/releases&#34;&gt;revision 2.3 of the microprofile metrics API&lt;/a&gt; was release earlier this year it introduced a new metric type called &lt;strong&gt;&lt;em&gt;Simple Timer&lt;/em&gt;&lt;/strong&gt;. Granted, with a name like that it&amp;rsquo;s easy to underestimate this new type - but don&amp;rsquo;t get tricked by its unspectacular title. Turns out, most of the time (especially in my projects where we also make use of &lt;a href=&#34;https://prometheus.io/&#34;&gt;Prometheus&lt;/a&gt;) it&amp;rsquo;s a way better suited and more flexible metric than i.e. its older cousin &lt;strong&gt;&lt;em&gt;Timer&lt;/em&gt;&lt;/strong&gt;.&lt;/p&gt;</description>
    </item>
    
    <item>
      <title>Response streaming between JAX-RS and Web-Components (Part 1)</title>
      <link>https://schoeffm.github.io/posts/response-streaming-between-jaxrs-and-webcomponents-part1/</link>
      <pubDate>Sat, 27 Jul 2019 11:18:59 +0200</pubDate>
      
      <guid>https://schoeffm.github.io/posts/response-streaming-between-jaxrs-and-webcomponents-part1/</guid>
      <description>&lt;p&gt;When dealing with JAX-RS resources are normally assembled completely in memory before being put onto the wire for transmission. If the resulting response fits into one single chunk the transmission is accomplished in one go - if the content is bigger than 16kB it will be split into several chunks of that size. You can see the difference in the response headers where a one-go-transmission contains the &lt;code&gt;Content-Length&lt;/code&gt;-header (where the server announces the size of the content to be transmitted) while a chunked transmission lacks the &lt;code&gt;Content-Length&lt;/code&gt; header but contains a &lt;code&gt;Transfer-Encoding: chunked&lt;/code&gt; header.&lt;/p&gt;</description>
    </item>
    
    <item>
      <title>API versioning using vender specific media types in JAX-RS</title>
      <link>https://schoeffm.github.io/posts/api-versioning-with-vendor-specific-media-types/</link>
      <pubDate>Mon, 10 Jun 2019 10:40:12 +0200</pubDate>
      
      <guid>https://schoeffm.github.io/posts/api-versioning-with-vendor-specific-media-types/</guid>
      <description>&lt;p&gt;Content Negotiation in JAX-RS allows you to leverage the information in the client requests &lt;code&gt;Accept&lt;/code&gt; header to map that request to a specific handler-method within your application. In combination with vendor-specific media types this approach can be used for &lt;a href=&#34;http://blog.steveklabnik.com/posts/2011-07-03-nobody-understands-rest-or-http&#34;&gt;versioning of an API&lt;/a&gt;.&lt;/p&gt;</description>
    </item>
    
  </channel>
</rss>
